/* tslint:disable */
/* eslint-disable */
/**
 * Daytona Server API
 * Daytona Server API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import type {
  CompletionList,
  ExecuteRequest,
  ExecuteResponse,
  FileInfo,
  GitAddRequest,
  GitBranchRequest,
  GitCloneRequest,
  GitCommitInfo,
  GitCommitRequest,
  GitCommitResponse,
  GitRepoRequest,
  GitStatus,
  ListBranchResponse,
  LspCompletionParams,
  LspDocumentRequest,
  LspServerRequest,
  LspSymbol,
  Match,
  ProjectDirResponse,
  ReplaceRequest,
  ReplaceResult,
  SearchFilesResponse,
} from '../models/index'
import {
  CompletionListFromJSON,
  CompletionListToJSON,
  ExecuteRequestFromJSON,
  ExecuteRequestToJSON,
  ExecuteResponseFromJSON,
  ExecuteResponseToJSON,
  FileInfoFromJSON,
  FileInfoToJSON,
  GitAddRequestFromJSON,
  GitAddRequestToJSON,
  GitBranchRequestFromJSON,
  GitBranchRequestToJSON,
  GitCloneRequestFromJSON,
  GitCloneRequestToJSON,
  GitCommitInfoFromJSON,
  GitCommitInfoToJSON,
  GitCommitRequestFromJSON,
  GitCommitRequestToJSON,
  GitCommitResponseFromJSON,
  GitCommitResponseToJSON,
  GitRepoRequestFromJSON,
  GitRepoRequestToJSON,
  GitStatusFromJSON,
  GitStatusToJSON,
  ListBranchResponseFromJSON,
  ListBranchResponseToJSON,
  LspCompletionParamsFromJSON,
  LspCompletionParamsToJSON,
  LspDocumentRequestFromJSON,
  LspDocumentRequestToJSON,
  LspServerRequestFromJSON,
  LspServerRequestToJSON,
  LspSymbolFromJSON,
  LspSymbolToJSON,
  MatchFromJSON,
  MatchToJSON,
  ProjectDirResponseFromJSON,
  ProjectDirResponseToJSON,
  ReplaceRequestFromJSON,
  ReplaceRequestToJSON,
  ReplaceResultFromJSON,
  ReplaceResultToJSON,
  SearchFilesResponseFromJSON,
  SearchFilesResponseToJSON,
} from '../models/index'

export interface FsCreateFolderRequest {
  workspaceId: string
  projectId: string
  path: string
  mode: string
}

export interface FsDeleteFileRequest {
  workspaceId: string
  projectId: string
  path: string
}

export interface FsDownloadFileRequest {
  workspaceId: string
  projectId: string
  path: string
}

export interface FsFindInFilesRequest {
  workspaceId: string
  projectId: string
  path: string
  pattern: string
}

export interface FsGetFileDetailsRequest {
  workspaceId: string
  projectId: string
  path: string
}

export interface FsListFilesRequest {
  workspaceId: string
  projectId: string
  path?: string
}

export interface FsMoveFileRequest {
  workspaceId: string
  projectId: string
  source: string
  destination: string
}

export interface FsReplaceInFilesRequest {
  workspaceId: string
  projectId: string
  replace: ReplaceRequest
}

export interface FsSearchFilesRequest {
  workspaceId: string
  projectId: string
  path: string
  pattern: string
}

export interface FsSetFilePermissionsRequest {
  workspaceId: string
  projectId: string
  path: string
  owner?: string
  group?: string
  mode?: string
}

export interface FsUploadFileRequest {
  workspaceId: string
  projectId: string
  path: string
  file: Blob
}

export interface GetProjectDirRequest {
  workspaceId: string
  projectId: string
}

export interface GitAddFilesRequest {
  workspaceId: string
  projectId: string
  params: GitAddRequest
}

export interface GitBranchListRequest {
  workspaceId: string
  projectId: string
  path: string
}

export interface GitCloneRepositoryRequest {
  workspaceId: string
  projectId: string
  params: GitCloneRequest
}

export interface GitCommitChangesRequest {
  workspaceId: string
  projectId: string
  params: GitCommitRequest
}

export interface GitCommitHistoryRequest {
  workspaceId: string
  projectId: string
  path: string
}

export interface GitCreateBranchRequest {
  workspaceId: string
  projectId: string
  params: GitBranchRequest
}

export interface GitGitStatusRequest {
  workspaceId: string
  projectId: string
  path: string
}

export interface GitPullChangesRequest {
  workspaceId: string
  projectId: string
  params: GitRepoRequest
}

export interface GitPushChangesRequest {
  workspaceId: string
  projectId: string
  params: GitRepoRequest
}

export interface LspCompletionsRequest {
  workspaceId: string
  projectId: string
  params: LspCompletionParams
}

export interface LspDidCloseRequest {
  workspaceId: string
  projectId: string
  params: LspDocumentRequest
}

export interface LspDidOpenRequest {
  workspaceId: string
  projectId: string
  params: LspDocumentRequest
}

export interface LspDocumentSymbolsRequest {
  workspaceId: string
  projectId: string
  languageId: string
  pathToProject: string
  uri: string
}

export interface LspStartRequest {
  workspaceId: string
  projectId: string
  params: LspServerRequest
}

export interface LspStopRequest {
  workspaceId: string
  projectId: string
  params: LspServerRequest
}

export interface LspWorkspaceSymbolsRequest {
  workspaceId: string
  projectId: string
  languageId: string
  pathToProject: string
  query: string
}

export interface ProcessExecuteCommandRequest {
  workspaceId: string
  projectId: string
  params: ExecuteRequest
}

/**
 *
 */
export class WorkspaceToolboxApi extends runtime.BaseAPI {
  /**
   * Create folder inside workspace project
   * Create folder
   */
  async fsCreateFolderRaw(
    requestParameters: FsCreateFolderRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsCreateFolder().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsCreateFolder().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsCreateFolder().',
      )
    }

    if (requestParameters['mode'] == null) {
      throw new runtime.RequiredError(
        'mode',
        'Required parameter "mode" was null or undefined when calling fsCreateFolder().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    if (requestParameters['mode'] != null) {
      queryParameters['mode'] = requestParameters['mode']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/folder`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Create folder inside workspace project
   * Create folder
   */
  async fsCreateFolder(
    requestParameters: FsCreateFolderRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.fsCreateFolderRaw(requestParameters, initOverrides)
  }

  /**
   * Delete file inside workspace project
   * Delete file
   */
  async fsDeleteFileRaw(
    requestParameters: FsDeleteFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsDeleteFile().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsDeleteFile().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsDeleteFile().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete file inside workspace project
   * Delete file
   */
  async fsDeleteFile(
    requestParameters: FsDeleteFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.fsDeleteFileRaw(requestParameters, initOverrides)
  }

  /**
   * Download file from workspace project
   * Download file
   */
  async fsDownloadFileRaw(
    requestParameters: FsDownloadFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Blob>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsDownloadFile().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsDownloadFile().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsDownloadFile().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/download`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.BlobApiResponse(response)
  }

  /**
   * Download file from workspace project
   * Download file
   */
  async fsDownloadFile(
    requestParameters: FsDownloadFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Blob> {
    const response = await this.fsDownloadFileRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Search for text/pattern inside workspace project files
   * Search for text/pattern in files
   */
  async fsFindInFilesRaw(
    requestParameters: FsFindInFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<Match>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsFindInFiles().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsFindInFiles().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsFindInFiles().',
      )
    }

    if (requestParameters['pattern'] == null) {
      throw new runtime.RequiredError(
        'pattern',
        'Required parameter "pattern" was null or undefined when calling fsFindInFiles().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    if (requestParameters['pattern'] != null) {
      queryParameters['pattern'] = requestParameters['pattern']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/find`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(MatchFromJSON),
    )
  }

  /**
   * Search for text/pattern inside workspace project files
   * Search for text/pattern in files
   */
  async fsFindInFiles(
    requestParameters: FsFindInFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<Match>> {
    const response = await this.fsFindInFilesRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Get file info inside workspace project
   * Get file info
   */
  async fsGetFileDetailsRaw(
    requestParameters: FsGetFileDetailsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<FileInfo>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsGetFileDetails().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsGetFileDetails().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsGetFileDetails().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/info`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      FileInfoFromJSON(jsonValue),
    )
  }

  /**
   * Get file info inside workspace project
   * Get file info
   */
  async fsGetFileDetails(
    requestParameters: FsGetFileDetailsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<FileInfo> {
    const response = await this.fsGetFileDetailsRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * List files inside workspace project
   * List files
   */
  async fsListFilesRaw(
    requestParameters: FsListFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<FileInfo>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsListFiles().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsListFiles().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(FileInfoFromJSON),
    )
  }

  /**
   * List files inside workspace project
   * List files
   */
  async fsListFiles(
    requestParameters: FsListFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<FileInfo>> {
    const response = await this.fsListFilesRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Create folder inside workspace project
   * Create folder
   */
  async fsMoveFileRaw(
    requestParameters: FsMoveFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsMoveFile().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsMoveFile().',
      )
    }

    if (requestParameters['source'] == null) {
      throw new runtime.RequiredError(
        'source',
        'Required parameter "source" was null or undefined when calling fsMoveFile().',
      )
    }

    if (requestParameters['destination'] == null) {
      throw new runtime.RequiredError(
        'destination',
        'Required parameter "destination" was null or undefined when calling fsMoveFile().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['source'] != null) {
      queryParameters['source'] = requestParameters['source']
    }

    if (requestParameters['destination'] != null) {
      queryParameters['destination'] = requestParameters['destination']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/move`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Create folder inside workspace project
   * Create folder
   */
  async fsMoveFile(
    requestParameters: FsMoveFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.fsMoveFileRaw(requestParameters, initOverrides)
  }

  /**
   * Repleace text/pattern in mutilple files inside workspace project
   * Repleace text/pattern in files
   */
  async fsReplaceInFilesRaw(
    requestParameters: FsReplaceInFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<ReplaceResult>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsReplaceInFiles().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsReplaceInFiles().',
      )
    }

    if (requestParameters['replace'] == null) {
      throw new runtime.RequiredError(
        'replace',
        'Required parameter "replace" was null or undefined when calling fsReplaceInFiles().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/replace`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ReplaceRequestToJSON(requestParameters['replace']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(ReplaceResultFromJSON),
    )
  }

  /**
   * Repleace text/pattern in mutilple files inside workspace project
   * Repleace text/pattern in files
   */
  async fsReplaceInFiles(
    requestParameters: FsReplaceInFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<ReplaceResult>> {
    const response = await this.fsReplaceInFilesRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Search for files inside workspace project
   * Search for files
   */
  async fsSearchFilesRaw(
    requestParameters: FsSearchFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<SearchFilesResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsSearchFiles().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsSearchFiles().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsSearchFiles().',
      )
    }

    if (requestParameters['pattern'] == null) {
      throw new runtime.RequiredError(
        'pattern',
        'Required parameter "pattern" was null or undefined when calling fsSearchFiles().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    if (requestParameters['pattern'] != null) {
      queryParameters['pattern'] = requestParameters['pattern']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/search`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SearchFilesResponseFromJSON(jsonValue),
    )
  }

  /**
   * Search for files inside workspace project
   * Search for files
   */
  async fsSearchFiles(
    requestParameters: FsSearchFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<SearchFilesResponse> {
    const response = await this.fsSearchFilesRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Set file owner/group/permissions inside workspace project
   * Set file owner/group/permissions
   */
  async fsSetFilePermissionsRaw(
    requestParameters: FsSetFilePermissionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsSetFilePermissions().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsSetFilePermissions().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsSetFilePermissions().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    if (requestParameters['owner'] != null) {
      queryParameters['owner'] = requestParameters['owner']
    }

    if (requestParameters['group'] != null) {
      queryParameters['group'] = requestParameters['group']
    }

    if (requestParameters['mode'] != null) {
      queryParameters['mode'] = requestParameters['mode']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/permissions`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Set file owner/group/permissions inside workspace project
   * Set file owner/group/permissions
   */
  async fsSetFilePermissions(
    requestParameters: FsSetFilePermissionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.fsSetFilePermissionsRaw(requestParameters, initOverrides)
  }

  /**
   * Upload file inside workspace project
   * Upload file
   */
  async fsUploadFileRaw(
    requestParameters: FsUploadFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling fsUploadFile().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling fsUploadFile().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling fsUploadFile().',
      )
    }

    if (requestParameters['file'] == null) {
      throw new runtime.RequiredError(
        'file',
        'Required parameter "file" was null or undefined when calling fsUploadFile().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const consumes: runtime.Consume[] = [{ contentType: 'multipart/form-data' }]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters['file'] != null) {
      formParams.append('file', requestParameters['file'] as any)
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/files/upload`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Upload file inside workspace project
   * Upload file
   */
  async fsUploadFile(
    requestParameters: FsUploadFileRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.fsUploadFileRaw(requestParameters, initOverrides)
  }

  /**
   * Get project directory
   * Get project dir
   */
  async getProjectDirRaw(
    requestParameters: GetProjectDirRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ProjectDirResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling getProjectDir().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling getProjectDir().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/project-dir`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectDirResponseFromJSON(jsonValue),
    )
  }

  /**
   * Get project directory
   * Get project dir
   */
  async getProjectDir(
    requestParameters: GetProjectDirRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ProjectDirResponse> {
    const response = await this.getProjectDirRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Add files to git commit
   * Add files
   */
  async gitAddFilesRaw(
    requestParameters: GitAddFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitAddFiles().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitAddFiles().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling gitAddFiles().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/add`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GitAddRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Add files to git commit
   * Add files
   */
  async gitAddFiles(
    requestParameters: GitAddFilesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.gitAddFilesRaw(requestParameters, initOverrides)
  }

  /**
   * Get branch list from git repository inside workspace project
   * Get branch list
   */
  async gitBranchListRaw(
    requestParameters: GitBranchListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListBranchResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitBranchList().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitBranchList().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling gitBranchList().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/branches`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListBranchResponseFromJSON(jsonValue),
    )
  }

  /**
   * Get branch list from git repository inside workspace project
   * Get branch list
   */
  async gitBranchList(
    requestParameters: GitBranchListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListBranchResponse> {
    const response = await this.gitBranchListRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Clone git repository inside workspace project
   * Clone git repository
   */
  async gitCloneRepositoryRaw(
    requestParameters: GitCloneRepositoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitCloneRepository().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitCloneRepository().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling gitCloneRepository().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/clone`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GitCloneRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Clone git repository inside workspace project
   * Clone git repository
   */
  async gitCloneRepository(
    requestParameters: GitCloneRepositoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.gitCloneRepositoryRaw(requestParameters, initOverrides)
  }

  /**
   * Commit changes to git repository inside workspace project
   * Commit changes
   */
  async gitCommitChangesRaw(
    requestParameters: GitCommitChangesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<GitCommitResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitCommitChanges().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitCommitChanges().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling gitCommitChanges().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/commit`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GitCommitRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GitCommitResponseFromJSON(jsonValue),
    )
  }

  /**
   * Commit changes to git repository inside workspace project
   * Commit changes
   */
  async gitCommitChanges(
    requestParameters: GitCommitChangesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<GitCommitResponse> {
    const response = await this.gitCommitChangesRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Get commit history from git repository inside workspace project
   * Get commit history
   */
  async gitCommitHistoryRaw(
    requestParameters: GitCommitHistoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<GitCommitInfo>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitCommitHistory().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitCommitHistory().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling gitCommitHistory().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/history`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(GitCommitInfoFromJSON),
    )
  }

  /**
   * Get commit history from git repository inside workspace project
   * Get commit history
   */
  async gitCommitHistory(
    requestParameters: GitCommitHistoryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<GitCommitInfo>> {
    const response = await this.gitCommitHistoryRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Create branch on git repository inside workspace project
   * Create branch
   */
  async gitCreateBranchRaw(
    requestParameters: GitCreateBranchRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitCreateBranch().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitCreateBranch().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling gitCreateBranch().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/branches`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GitBranchRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Create branch on git repository inside workspace project
   * Create branch
   */
  async gitCreateBranch(
    requestParameters: GitCreateBranchRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.gitCreateBranchRaw(requestParameters, initOverrides)
  }

  /**
   * Get status from git repository inside workspace project
   * Get git status
   */
  async gitGitStatusRaw(
    requestParameters: GitGitStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<GitStatus>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitGitStatus().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitGitStatus().',
      )
    }

    if (requestParameters['path'] == null) {
      throw new runtime.RequiredError(
        'path',
        'Required parameter "path" was null or undefined when calling gitGitStatus().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['path'] != null) {
      queryParameters['path'] = requestParameters['path']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/status`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GitStatusFromJSON(jsonValue),
    )
  }

  /**
   * Get status from git repository inside workspace project
   * Get git status
   */
  async gitGitStatus(
    requestParameters: GitGitStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<GitStatus> {
    const response = await this.gitGitStatusRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Pull changes from remote to git repository inside workspace project
   * Pull changes
   */
  async gitPullChangesRaw(
    requestParameters: GitPullChangesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitPullChanges().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitPullChanges().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling gitPullChanges().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/pull`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GitRepoRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Pull changes from remote to git repository inside workspace project
   * Pull changes
   */
  async gitPullChanges(
    requestParameters: GitPullChangesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.gitPullChangesRaw(requestParameters, initOverrides)
  }

  /**
   * Push changes to remote from git repository inside workspace project
   * Push changes
   */
  async gitPushChangesRaw(
    requestParameters: GitPushChangesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling gitPushChanges().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling gitPushChanges().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling gitPushChanges().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/git/push`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GitRepoRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Push changes to remote from git repository inside workspace project
   * Push changes
   */
  async gitPushChanges(
    requestParameters: GitPushChangesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.gitPushChangesRaw(requestParameters, initOverrides)
  }

  /**
   * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
   * Get Lsp Completions
   */
  async lspCompletionsRaw(
    requestParameters: LspCompletionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<CompletionList>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspCompletions().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspCompletions().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling lspCompletions().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/completions`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LspCompletionParamsToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CompletionListFromJSON(jsonValue),
    )
  }

  /**
   * The Completion request is sent from the client to the server to compute completion items at a given cursor position.
   * Get Lsp Completions
   */
  async lspCompletions(
    requestParameters: LspCompletionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<CompletionList> {
    const response = await this.lspCompletionsRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * The document close notification is sent from the client to the server when the document got closed in the client.
   * Call Lsp DidClose
   */
  async lspDidCloseRaw(
    requestParameters: LspDidCloseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspDidClose().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspDidClose().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling lspDidClose().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/did-close`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LspDocumentRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * The document close notification is sent from the client to the server when the document got closed in the client.
   * Call Lsp DidClose
   */
  async lspDidClose(
    requestParameters: LspDidCloseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.lspDidCloseRaw(requestParameters, initOverrides)
  }

  /**
   * The document open notification is sent from the client to the server to signal newly opened text documents.
   * Call Lsp DidOpen
   */
  async lspDidOpenRaw(
    requestParameters: LspDidOpenRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspDidOpen().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspDidOpen().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling lspDidOpen().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/did-open`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LspDocumentRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * The document open notification is sent from the client to the server to signal newly opened text documents.
   * Call Lsp DidOpen
   */
  async lspDidOpen(
    requestParameters: LspDidOpenRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.lspDidOpenRaw(requestParameters, initOverrides)
  }

  /**
   * The document symbol request is sent from the client to the server.
   * Call Lsp DocumentSymbols
   */
  async lspDocumentSymbolsRaw(
    requestParameters: LspDocumentSymbolsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<LspSymbol>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspDocumentSymbols().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspDocumentSymbols().',
      )
    }

    if (requestParameters['languageId'] == null) {
      throw new runtime.RequiredError(
        'languageId',
        'Required parameter "languageId" was null or undefined when calling lspDocumentSymbols().',
      )
    }

    if (requestParameters['pathToProject'] == null) {
      throw new runtime.RequiredError(
        'pathToProject',
        'Required parameter "pathToProject" was null or undefined when calling lspDocumentSymbols().',
      )
    }

    if (requestParameters['uri'] == null) {
      throw new runtime.RequiredError(
        'uri',
        'Required parameter "uri" was null or undefined when calling lspDocumentSymbols().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['languageId'] != null) {
      queryParameters['languageId'] = requestParameters['languageId']
    }

    if (requestParameters['pathToProject'] != null) {
      queryParameters['pathToProject'] = requestParameters['pathToProject']
    }

    if (requestParameters['uri'] != null) {
      queryParameters['uri'] = requestParameters['uri']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/document-symbols`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(LspSymbolFromJSON),
    )
  }

  /**
   * The document symbol request is sent from the client to the server.
   * Call Lsp DocumentSymbols
   */
  async lspDocumentSymbols(
    requestParameters: LspDocumentSymbolsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<LspSymbol>> {
    const response = await this.lspDocumentSymbolsRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Start Lsp server process inside workspace project
   * Start Lsp server
   */
  async lspStartRaw(
    requestParameters: LspStartRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspStart().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspStart().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling lspStart().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/start`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LspServerRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Start Lsp server process inside workspace project
   * Start Lsp server
   */
  async lspStart(
    requestParameters: LspStartRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.lspStartRaw(requestParameters, initOverrides)
  }

  /**
   * Stop Lsp server process inside workspace project
   * Stop Lsp server
   */
  async lspStopRaw(
    requestParameters: LspStopRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspStop().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspStop().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling lspStop().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/stop`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LspServerRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Stop Lsp server process inside workspace project
   * Stop Lsp server
   */
  async lspStop(
    requestParameters: LspStopRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.lspStopRaw(requestParameters, initOverrides)
  }

  /**
   * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
   * Call Lsp WorkspaceSymbols
   */
  async lspWorkspaceSymbolsRaw(
    requestParameters: LspWorkspaceSymbolsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<LspSymbol>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling lspWorkspaceSymbols().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling lspWorkspaceSymbols().',
      )
    }

    if (requestParameters['languageId'] == null) {
      throw new runtime.RequiredError(
        'languageId',
        'Required parameter "languageId" was null or undefined when calling lspWorkspaceSymbols().',
      )
    }

    if (requestParameters['pathToProject'] == null) {
      throw new runtime.RequiredError(
        'pathToProject',
        'Required parameter "pathToProject" was null or undefined when calling lspWorkspaceSymbols().',
      )
    }

    if (requestParameters['query'] == null) {
      throw new runtime.RequiredError(
        'query',
        'Required parameter "query" was null or undefined when calling lspWorkspaceSymbols().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['languageId'] != null) {
      queryParameters['languageId'] = requestParameters['languageId']
    }

    if (requestParameters['pathToProject'] != null) {
      queryParameters['pathToProject'] = requestParameters['pathToProject']
    }

    if (requestParameters['query'] != null) {
      queryParameters['query'] = requestParameters['query']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/lsp/workspace-symbols`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(LspSymbolFromJSON),
    )
  }

  /**
   * The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
   * Call Lsp WorkspaceSymbols
   */
  async lspWorkspaceSymbols(
    requestParameters: LspWorkspaceSymbolsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<LspSymbol>> {
    const response = await this.lspWorkspaceSymbolsRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Execute command synchronously inside workspace project
   * Execute command
   */
  async processExecuteCommandRaw(
    requestParameters: ProcessExecuteCommandRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ExecuteResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling processExecuteCommand().',
      )
    }

    if (requestParameters['projectId'] == null) {
      throw new runtime.RequiredError(
        'projectId',
        'Required parameter "projectId" was null or undefined when calling processExecuteCommand().',
      )
    }

    if (requestParameters['params'] == null) {
      throw new runtime.RequiredError(
        'params',
        'Required parameter "params" was null or undefined when calling processExecuteCommand().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = await this.configuration.apiKey(
        'Authorization',
      ) // Bearer authentication
    }

    const response = await this.request(
      {
        path: `/workspace/{workspaceId}/{projectId}/toolbox/process/execute`
          .replace(
            `{${'workspaceId'}}`,
            encodeURIComponent(String(requestParameters['workspaceId'])),
          )
          .replace(
            `{${'projectId'}}`,
            encodeURIComponent(String(requestParameters['projectId'])),
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ExecuteRequestToJSON(requestParameters['params']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ExecuteResponseFromJSON(jsonValue),
    )
  }

  /**
   * Execute command synchronously inside workspace project
   * Execute command
   */
  async processExecuteCommand(
    requestParameters: ProcessExecuteCommandRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ExecuteResponse> {
    const response = await this.processExecuteCommandRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }
}
